class Solution {
public:
    int maximalSquare(vector<vector<char>>& matrix) {
        // dp[i][j]: 到坐标【i，j】的最大正方形的某种相关，比如边长
        // 在长方形中的正方形，边长 = min（长，宽）
        // dp1【i】【j】 存到坐标【i，j】结束的长
        // dp2【i】【j】 存到坐标【i，j】结束的宽
        // dp1[0][0] = 1, dp2[0][0] =1
        // dp1[0][1] = 0, dp2[0][1] =0
        // dp1[0][2] = 1, dp2[0][2] =1
        // dp1[0][3] = 0, dp2[0][3] =0
        // dp1[0][4] = 0, dp2[0][4] =0

        // dp1[1][0] = 1, dp2[1][0] =2
        // dp1[1][1] = 0, dp2[1][1] =0
        // dp1[1][2] = 1, dp2[1][2] =2
        // dp1[1][3] = 2, dp2[1][3] =1
        // dp1[1][4] = 3, dp2[0][4] =1

        // dp1[2][0] = 1, dp2[2][0] =3
        // dp1[2][1] = 2, dp2[2][1] =1
        // dp1[2][2] = 3, dp2[2][2] =3, dp[2][2] = matrix[2][2] == 1?min(dp[1][2], dp[2][1], dp[1][1]) + 1
        // dp1[2][3] = 4, dp2[2][3] =2
        // dp1[2][4] = 5, dp2[2][4] =2

        // dp1[3][0] = 1, dp2[3][0] =4
        // dp1[3][1] = 0, dp2[3][1] =0
        // dp1[3][2] = 0, dp2[3][2] =0
        // dp1[3][3] = 1, dp2[1][3] =3
        // dp1[3][4] = 0, dp2[0][4] =0

        // dp[i][j] ：到坐标【i，j】结束的只含有1的正方形的边
        // dp[0][0] = 1, dp[0][1] = 0, dp[0][2] = 1, dp[0][3]= 0, dp[0][4] = 0
        // dp[1][0] = 1, dp[1][1] = 0, dp[1][2] = 1, dp[1][3]= 1, dp[1][4] = 1
        // dp[2][0] = 1, dp[2][1] = 1, dp[2][2] = 1, dp[2][3]= 2, dp[2][4] = 2
        // dp[3][0] = 1, dp[3][1] = 0, dp[3][2] = 0, dp[2][3]= 1, dp[2][4] = 0

        // dp[i][j] = min(dp[i-1][j-1], dp[i][j-1], dp[i-1][j]) + 1
        const int n = matrix.size(), m = matrix[0].size();

        vector<vector<int>> dp(n+1, vector<int>(m+1));
        int ans = 0;
        for(int i=1;i<=n;++i) {
            for(int j=1;j<=m;++j) {
                if (matrix[i-1][j-1] == '1') {
                    dp[i][j] = min(dp[i-1][j-1], min(dp[i][j-1], dp[i-1][j])) + 1;
                    ans = max(ans, dp[i][j] * dp[i][j]);
                }
            }
        }
        return ans;
    }
};
